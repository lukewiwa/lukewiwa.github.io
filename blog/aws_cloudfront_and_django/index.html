<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>AWS cloudfront and Django</title><link rel="stylesheet" href="https://unpkg.com/tachyons@4.12.0/css/tachyons.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css"><link rel="stylesheet" href="/index.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/github.min.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/github-dark.min.css" media="screen and (prefers-color-scheme: dark)"></head><body><header><nav class="flex flex-row items-center justify-between"><a href="/" class="link nav-brand no-underline dtc w-25 f3">Wiwa</a><div class="dtc v-mid w-75 tr"><a href="/blog" class="link nav-link f6 f5-ns dib mr3 mr4-ns b">Blog</a><a href="/projects" class="link nav-link f6 f5-ns dib mr3 mr4-ns ">Projects</a></div></nav></header><main class="pt-4"><article><h1 class="f2">AWS cloudfront and Django</h1><time class="db mb1 gray">2025-02-19</time><div><p>If you are hosting a web app on AWS you should be putting a Cloudfront instance in front of it. There are a few advantages but at the end of the day it's cheaper, allows for global caching at the edge and provides a fairly straight forward way to obtain SSL certificates. But it seems really annoying and difficult to get it working with a Django app given Django's security model around the allowed hosts.</p>
<!--more-->
<p>I had a few goes at this and at first did a complicated version that used <code>x-forwarded-host</code> headers and cloudfront functions but turns out the solution is somewhat simpler. We really need to keep three things in mind here.</p>
<p>First is that we need to allow all http methods. By default cloudfront only allows GET and OPTIONS, any writable http requests need to be explicitly allowed.</p>
<p>Secondly we need to be aware of the caching strategy. By default the AWS predefined CACHE OPTIMIZED strategy doesn't take into account cookies or query strings. In your typical django project we'll need both included to address user accounts and list views among other things.</p>
<p>Finally to forward the original domain header through to the django application we need to use the origin request policy to <code>ALL_VIEWER_EXCEPT_HOST_HEADER</code>. Then we can set the domain in django settings in <code>ALLOWED_HOSTS</code> and the application should work as expected. There is a predefined AWS origin request policy named <code>ALL_VIEWER</code> but that will send through the host header as the cloudfront distribution domain and Django will error out with an unexpected host header error.</p>
<p>I believe this cloudfront configuration should work for any origin that cloudfront is setup against but I've only really tested it with API Gateway. Below is a CDK representation of this configuration.</p>
<pre><code class="language-typescript hljs">
<span class="hljs-keyword">const</span> cachePolicy = <span class="hljs-keyword">new</span> cloudfront.<span class="hljs-title class_">CachePolicy</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">"CachePolicy"</span>, {
  <span class="hljs-attr">cookieBehavior</span>: cloudfront.<span class="hljs-property">CacheCookieBehavior</span>.<span class="hljs-title function_">all</span>(),
  <span class="hljs-attr">queryStringBehavior</span>: cloudfront.<span class="hljs-property">CacheQueryStringBehavior</span>.<span class="hljs-title function_">all</span>(),
});

<span class="hljs-keyword">const</span> distribution = <span class="hljs-keyword">new</span> cloudfront.<span class="hljs-title class_">Distribution</span>(
  <span class="hljs-variable language_">this</span>,
  <span class="hljs-string">"CloudfrontDistribution"</span>,
  {
    <span class="hljs-attr">domainNames</span>: [<span class="hljs-string">"your-domain-name.com"</span>],
    <span class="hljs-attr">defaultBehavior</span>: {
      <span class="hljs-comment">// This could be a load balancer or an API gateway</span>
      <span class="hljs-comment">// or any number of AWS services</span>
      <span class="hljs-attr">origin</span>: <span class="hljs-keyword">new</span> origins.<span class="hljs-title class_">HttpOrigin</span>(
        <span class="hljs-string">`internalAWSdomain.com`</span>
      ),
      cachePolicy,
      <span class="hljs-attr">originRequestPolicy</span>:
        cloudfront.<span class="hljs-property">OriginRequestPolicy</span>.<span class="hljs-property">ALL_VIEWER_EXCEPT_HOST_HEADER</span>,
      <span class="hljs-attr">allowedMethods</span>: cloudfront.<span class="hljs-property">AllowedMethods</span>.<span class="hljs-property">ALLOW_ALL</span>,
      <span class="hljs-attr">viewerProtocolPolicy</span>:
        cloudfront.<span class="hljs-property">ViewerProtocolPolicy</span>.<span class="hljs-property">REDIRECT_TO_HTTPS</span>,
    },
  }
);
</code></pre>
</div></article></main></body></html>